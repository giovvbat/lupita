struct Data {
    value int;
    active bool;
}

struct BinarySearchTree {
    tree vector<Data>;
}

function left_child(index int) int {
    return 2 * index + 1;
}

function right_child(index int) int {
    return 2 * index + 2;
}

procedure ensure_size(&bst BinarySearchTree, index int) {
    while (length(bst.tree) <= index) {
        data Data;
        push(bst.tree, data);
    }
}

procedure insert_recursive(&bst BinarySearchTree, index int, value int) {
    ensure_size(bst, index);

    if (index < length(bst.tree)) {
        if (!bst.tree[index].active) {
            bst.tree[index].value = value;
            bst.tree[index].active = true;
        } else {
            if (value < bst.tree[index].value) {
                insert_recursive(bst, left_child(index), value);
            } else {
                insert_recursive(bst, right_child(index), value);
            }
        }
    }
}

procedure insert(&bst BinarySearchTree, value int) {
    insert_recursive(bst, 0, value);
}

procedure insert_values(&bst BinarySearchTree, values vector<int>) {
    for (i int = 0; i < length(values); i += 1) {
        insert(bst, values[i]);
    }
}

function min_recursive(bst BinarySearchTree, index int, &level int) Data {
    if (index < length(bst.tree)) {
        if (bst.tree[index].active) {
            left int = left_child(index);

            if (left < length(bst.tree)) {
                if (bst.tree[left].active) {
                    level += 1;
                    return min_recursive(bst, left, level);
                }
            }

            return bst.tree[index];
        }
    }

    d Data;
    return d;
}

function min(bst BinarySearchTree, &level int) Data {
    level = 1;
    return min_recursive(bst, 0, level);
}

function max_recursive(bst BinarySearchTree, index int, &level int) Data {
    if (index < length(bst.tree)) {
        if (bst.tree[index].active) {
            right int = right_child(index);

            if (right < length(bst.tree)) {
                if (bst.tree[right].active) {
                    level += 1;
                    return max_recursive(bst, right, level);
                }
            }

            return bst.tree[index];
        }
    }

    d Data;
    return d;
}

function max(bst BinarySearchTree, &level int) Data {
    level = 1;
    return max_recursive(bst, 0, level);
}

procedure print_tree_by_level(&bst BinarySearchTree) {
    level int = 0;
    start int = 0;

    len int = length(bst.tree);

    while (start < len) {
        count int = 2 ^ level;
        end int;
        if (start + count > len) {
            end = len;
        } else {
            end = start + count;
        }

        print("Level " + (level + 1) + ":");

        for (i int = start; i < end; i += 1) {
            if (bst.tree[i].active) {
                print(bst.tree[i].value);
            }
        }

        print();

        start += count;
        level += 1;
    }
}

procedure main() {
    data vector<int>;
    bst BinarySearchTree;

    push(data, 8);
    push(data, 3);
    push(data, -5);
    push(data, 10);
    push(data, -13);
    push(data, 4);
    push(data, 7);
    push(data, 14);
    push(data, 13);

    print("Inserting into Binary Search Tree: " + data);
    insert_values(bst, data);

    print();

    level int;

    min_val Data = min(bst, level);
    print("Min: " + min_val.value + " at level " + level);

    max_val Data = max(bst, level);
    print("Max: " + max_val.value + " at level " + level);

    print();

    print("Printing tree level by level: \n");

    print_tree_by_level(bst);
}
